// utils/menuluRolUtils.js (G√úNCELLENMƒ∞≈û KOD)
const { EmbedBuilder, ActionRowBuilder, StringSelectMenuBuilder, ChannelType } = require('discord.js'); // ButtonBuilder kaldƒ±rƒ±ldƒ±, StringSelectMenuBuilder eklendi
const { getSystemSettings, saveSystemSettings, getBotStats, saveBotStats } = require('./db');
const { MENULU_ROL_CHANNEL_ID, NSFW_ROLE_ID, HABER_ROLE_ID, DUYURU_ROLE_ID, ANIME_TAKIPCI_ROLE_ID, ANIME_HABER_ROLE_ID, ROLE_LOG_CHANNEL_ID } = require('./config');

// Roller ve a√ßƒ±klamalarƒ± (Aynƒ± kalacak)
const ROLES_INFO = [
    {
        id: NSFW_ROLE_ID,
        name: 'NSFW ƒ∞√ßerik Rol√º',
        emoji: 'üîû',
        description: 'Sunucudaki NSFW kanallarƒ±nƒ± g√∂rmek i√ßin bu rol√º alƒ±n.'
    },
    {
        id: HABER_ROLE_ID,
        name: 'Anime Haber Bildirimleri Rol√º',
        emoji: 'üì∞',
        description: 'G√ºncel anime haber bildirimlerini almak i√ßin bu rol√º alƒ±n.'
    },
    {
        id: DUYURU_ROLE_ID,
        name: 'Duyuru Bildirimleri Rol√º',
        emoji: 'üì¢',
        description: '√ñnemli duyurulardan haberdar olmak i√ßin bu rol√º alƒ±n.'
    },
    {
        id: ANIME_TAKIPCI_ROLE_ID,
        name: 'Anime Takip√ßisi Rol√º',
        emoji: 'üå∏',
        description: 'Yeni anime ve b√∂l√ºm duyurularƒ±nƒ± almak i√ßin bu rol√º alƒ±n.'
    }

].filter(role => role.id); // config'de ID'si girilmeyen rolleri filtrele

/**
 * Men√ºl√º rol sistemi mesajƒ±nƒ± olu≈üturur ve g√∂nderir/g√ºnceller.
 * @param {Client} client Discord bot client
 * @param {Message|CommandInteraction} interactionOrMessage Mesaj veya etkile≈üim objesi
 * @param {boolean} isInitialSetup ƒ∞lk kurulum mu (mesajƒ± silip yeniden g√∂ndermek i√ßin)
 */
async function sendOrUpdateRoleMenu(client, interactionOrMessage, isInitialSetup = false) {
    let settings = getSystemSettings();

    // Kanal ID'si belirtilmemi≈üse veya ge√ßersizse hata ver
    if (!MENULU_ROL_CHANNEL_ID) {
        const replyContent = 'Hata: `config.js` dosyasƒ±nda `MENULU_ROL_CHANNEL_ID` belirtilmemi≈ü. L√ºtfen ayarlayƒ±n.';
        if (interactionOrMessage.replied || interactionOrMessage.deferred) {
            await interactionOrMessage.editReply({ content: replyContent, ephemeral: true });
        } else {
            await interactionOrMessage.reply({ content: replyContent, ephemeral: true });
        }
        return false;
    }

    const targetChannel = await client.channels.fetch(MENULU_ROL_CHANNEL_ID).catch(() => null);

    if (!targetChannel || targetChannel.type !== ChannelType.GuildText) {
        const replyContent = `Hata: Men√ºl√º rol kanalƒ± (${MENULU_ROL_CHANNEL_ID}) bulunamadƒ± veya bir metin kanalƒ± deƒüil.`;
        if (interactionOrMessage.replied || interactionOrMessage.deferred) {
            await interactionOrMessage.editReply({ content: replyContent, ephemeral: true });
        } else {
            await interactionOrMessage.reply({ content: replyContent, ephemeral: true });
        }
        return false;
    }

    const embed = new EmbedBuilder()
        .setColor('#0099ff')
        .setTitle('üì¢ Rol Se√ßim Men√ºs√º')
        .setDescription(
            'A≈üaƒüƒ±daki a√ßƒ±lƒ±r men√ºden istediƒüiniz rolleri alabilir veya mevcut rollerinizi kaldƒ±rabilirsiniz.\n' +
            'Sadece ilgilendiƒüiniz bildirimleri almak i√ßin se√ßim yapƒ±n.'
        )
        .addFields(
            ROLES_INFO.map(role => ({
                name: `${role.emoji} ${role.name}`,
                value: role.description,
                inline: false
            }))
        )
        .setFooter({ text: 'SomeSub Bot | Rol Almak/Kaldƒ±rmak ƒ∞√ßin Se√ßim Yap', iconURL: client.user.displayAvatarURL() })
        .setTimestamp();

    // Select Men√º Olu≈üturma
    const options = ROLES_INFO.map(role => ({
        label: role.name,
        description: role.description.length > 50 ? role.description.substring(0, 47) + '...' : role.description, // Max 50 karakter
        value: role.id,
        emoji: role.emoji,
    })).filter(option => option.value); // Ge√ßersiz rol ID'si olanlarƒ± filtrele

    if (options.length === 0) {
        const replyContent = 'Hata: Tanƒ±mlanmƒ±≈ü ge√ßerli rol bulunamadƒ±. L√ºtfen `config.js` dosyasƒ±ndaki rol ID\'lerini kontrol edin.';
        if (interactionOrMessage.replied || interactionOrMessage.deferred) {
            await interactionOrMessage.editReply({ content: replyContent, ephemeral: true });
        } else {
            await interactionOrMessage.reply({ content: replyContent, ephemeral: true });
        }
        return false;
    }

    const selectMenu = new StringSelectMenuBuilder()
        .setCustomId('role_select_menu') // √ñzel ID
        .setPlaceholder('Rol almak veya kaldƒ±rmak i√ßin se√ßin...')
        .addOptions(options)
        .setMinValues(0) // Kullanƒ±cƒ± hi√ßbir ≈üey se√ßmeden de g√∂nderebilir (yani mevcut rolleri kaldƒ±rabilir)
        .setMaxValues(options.length); // T√ºm rolleri se√ßebilir

    const actionRow = new ActionRowBuilder().addComponents(selectMenu);

    try {
        let sentMessage;
        if (settings.menuluRolSistemi.active && settings.menuluRolSistemi.messageId && settings.menuluRolSistemi.channelId === MENULU_ROL_CHANNEL_ID) {
            try {
                // Mesaj zaten varsa g√ºncelleyelim
                sentMessage = await targetChannel.messages.fetch(settings.menuluRolSistemi.messageId);
                await sentMessage.edit({ embeds: [embed], components: [actionRow] });
            } catch (err) {
                console.warn('Mevcut men√º mesajƒ± bulunamadƒ± veya eri≈üilemiyor, yeni mesaj g√∂nderiliyor:', err.message);
                sentMessage = await targetChannel.send({ embeds: [embed], components: [actionRow] });
            }
        } else {
            // Sistem ilk kez a√ßƒ±lƒ±yorsa veya mesaj ID'si/kanal ID'si deƒüi≈ümi≈üse eski mesajƒ± silip yeni g√∂nder
            if (settings.menuluRolSistemi.messageId && settings.menuluRolSistemi.channelId) {
                try {
                    const oldChannel = await client.channels.fetch(settings.menuluRolSistemi.channelId).catch(() => null);
                    if (oldChannel && oldChannel.type === ChannelType.GuildText) {
                        const oldMessage = await oldChannel.messages.fetch(settings.menuluRolSistemi.messageId).catch(() => null);
                        if (oldMessage) {
                            await oldMessage.delete();
                        }
                    }
                } catch (err) {
                    console.error('Eski men√º mesajƒ± silinirken hata:', err.message);
                }
            }
            sentMessage = await targetChannel.send({ embeds: [embed], components: [actionRow] });
        }

        settings.menuluRolSistemi.active = true;
        settings.menuluRolSistemi.messageId = sentMessage.id;
        settings.menuluRolSistemi.channelId = targetChannel.id;
        saveSystemSettings(settings);

        const replyContent = `Men√ºl√º rol sistemi ba≈üarƒ±yla ${targetChannel} kanalƒ±na kuruldu/g√ºncellendi!`;
        if (interactionOrMessage.replied || interactionOrMessage.deferred) {
            await interactionOrMessage.editReply({ content: replyContent, ephemeral: true });
        } else {
            await interactionOrMessage.reply({ content: replyContent, ephemeral: true });
        }
        return true;

    } catch (error) {
        console.error('Men√ºl√º rol men√ºs√º g√∂nderilirken/g√ºncellenirken hata:', error);
        const replyContent = 'Men√ºl√º rol men√ºs√º kurulurken bir hata olu≈ütu. Botun kanala mesaj g√∂nderme izni olduƒüundan emin olun.';
        if (interactionOrMessage.replied || interactionOrMessage.deferred) {
            await interactionOrMessage.editReply({ content: replyContent, ephemeral: true });
        } else {
            await interactionOrMessage.reply({ content: replyContent, ephemeral: true });
        }
        return false;
    }
}

/**
 * Men√ºl√º rol sistemini kapatƒ±r ve mesajƒ± siler. (AYNI KALACAK)
 * @param {Client} client Discord bot client
 * @param {Message|CommandInteraction} interactionOrMessage Mesaj veya etkile≈üim objesi
 */
async function disableRoleMenu(client, interactionOrMessage) {
    let settings = getSystemSettings();

    if (!settings.menuluRolSistemi.active) {
        const replyContent = 'Men√ºl√º rol sistemi zaten kapalƒ±.';
        if (interactionOrMessage.replied || interactionOrMessage.deferred) {
            await interactionOrMessage.editReply({ content: replyContent, ephemeral: true });
        } else {
            await interactionOrMessage.reply({ content: replyContent, ephemeral: true });
        }
        return false;
    }

    if (!settings.menuluRolSistemi.messageId || !settings.menuluRolSistemi.channelId) {
        settings.menuluRolSistemi.active = false;
        settings.menuluRolSistemi.messageId = null;
        settings.menuluRolSistemi.channelId = null;
        saveSystemSettings(settings);
        const replyContent = 'Men√ºl√º rol mesajƒ±nƒ±n ID\'si veya kanalƒ± bulunamadƒ±, ancak sistem kapatƒ±ldƒ±.';
        if (interactionOrMessage.replied || interactionOrMessage.deferred) {
            await interactionOrMessage.editReply({ content: replyContent, ephemeral: true });
        } else {
            await interactionOrMessage.reply({ content: replyContent, ephemeral: true });
        }
        return false;
    }

    const targetChannel = await client.channels.fetch(settings.menuluRolSistemi.channelId).catch(() => null);
    if (targetChannel && targetChannel.type === ChannelType.GuildText) {
        try {
            const messageToDelete = await targetChannel.messages.fetch(settings.menuluRolSistemi.messageId);
            if (messageToDelete) {
                await messageToDelete.delete();
            }
        } catch (err) {
            console.warn('Men√º mesajƒ± silinirken hata olu≈ütu veya zaten silinmi≈ü:', err.message);
        }
    }

    settings.menuluRolSistemi.active = false;
    settings.menuluRolSistemi.messageId = null;
    settings.menuluRolSistemi.channelId = null;
    saveSystemSettings(settings);

    const replyContent = 'Men√ºl√º rol sistemi ba≈üarƒ±yla kapatƒ±ldƒ± ve men√º mesajƒ± silindi.';
    if (interactionOrMessage.replied || interactionOrMessage.deferred) {
        await interactionOrMessage.editReply({ content: replyContent, ephemeral: true });
    } else {
        await interactionOrMessage.reply({ content: replyContent, ephemeral: true });
    }
    return true;
}

/**
 * Kullanƒ±cƒ±ya rol verir veya rol√ºn√º kaldƒ±rƒ±r ve istatistikleri g√ºnceller. (Bu fonksiyonun adƒ± deƒüi≈üecek veya ayrƒ± bir selectMenuToggleRoles fonksiyonu yazƒ±labilir)
 * Bu fonksiyon artƒ±k doƒürudan tek bir rol√º deƒüil, bir array'i y√∂netecek.
 * @param {StringSelectMenuInteraction} interaction Se√ßim men√ºs√º etkile≈üimi objesi
 * @param {string[]} selectedRoleIds Se√ßilen rollerin ID'leri
 */
async function processSelectedRoles(interaction, selectedRoleIds) {
    await interaction.deferReply({ ephemeral: true }); // Kullanƒ±cƒ±ya anlƒ±k geri bildirim ver

    const member = interaction.member;
    const client = interaction.client; // Log kanalƒ± i√ßin client'a eri≈üim
    let botStats = getBotStats();

    const rolesGiven = [];
    const rolesRemoved = [];
    const errors = [];

    // T√ºm tanƒ±mlƒ± rollerin ID'leri
    const allRoleIds = ROLES_INFO.map(r => r.id);

    for (const roleId of allRoleIds) {
        const role = interaction.guild.roles.cache.get(roleId);
        const roleInfo = ROLES_INFO.find(r => r.id === roleId);
        const roleName = roleInfo ? roleInfo.name : 'Bilinmeyen Rol';

        if (!role) {
            errors.push(`\`${roleName}\` rol√º bulunamadƒ±.`);
            continue;
        }

        if (selectedRoleIds.includes(roleId)) {
            // Eƒüer rol men√ºde se√ßilmi≈üse ve kullanƒ±cƒ±da yoksa, ver
            if (!member.roles.cache.has(roleId)) {
                try {
                    await member.roles.add(roleId);
                    rolesGiven.push(roleName);
                    if (typeof botStats.roleUsage[roleId] === 'undefined') {
                        botStats.roleUsage[roleId] = 0;
                    }
                    botStats.roleUsage[roleId]++; // Rol verildiƒüinde sayacƒ± artƒ±r
                    logRoleAction(client, member.user, roleName, 'Verildi', '00FF00'); // Ye≈üil
                } catch (error) {
                    errors.push(`\`${roleName}\` rol√º verilemedi.`);
                    logRoleAction(client, member.user, roleName, 'Ba≈üarƒ±sƒ±z (Verilemedi)', 'FF0000', error.message);
                }
            }
        } else {
            // Eƒüer rol men√ºde se√ßilmemi≈üse ve kullanƒ±cƒ±da varsa, kaldƒ±r
            if (member.roles.cache.has(roleId)) {
                try {
                    await member.roles.remove(roleId);
                    rolesRemoved.push(roleName);
                    if (typeof botStats.roleUsage[roleId] === 'undefined') { // Olur da eksik olursa diye kontrol
                        botStats.roleUsage[roleId] = 0;
                    }
                    if (botStats.roleUsage[roleId] > 0) { // Negatife d√º≈ümemesi i√ßin
                        botStats.roleUsage[roleId]--; // Rol alƒ±ndƒ±ƒüƒ±nda sayacƒ± azalt
                    }
                    logRoleAction(client, member.user, roleName, 'Alƒ±ndƒ±', 'FFA500'); // Turuncu
                } catch (error) {
                    errors.push(`\`${roleName}\` rol√º kaldƒ±rƒ±lamadƒ±.`);
                    logRoleAction(client, member.user, roleName, 'Ba≈üarƒ±sƒ±z (Kaldƒ±rƒ±lamadƒ±)', 'FF0000', error.message);
                }
            }
        }
    }

    saveBotStats(botStats); // T√ºm deƒüi≈üiklikleri bir kerede kaydet

    let replyMessage = '';
    if (rolesGiven.length > 0) {
        replyMessage += `‚úÖ Ba≈üarƒ±yla verilen roller: ${rolesGiven.map(r => `\`${r}\``).join(', ')}\n`;
    }
    if (rolesRemoved.length > 0) {
        replyMessage += `‚ùå Ba≈üarƒ±yla kaldƒ±rƒ±lan roller: ${rolesRemoved.map(r => `\`${r}\``).join(', ')}\n`;
    }
    if (errors.length > 0) {
        replyMessage += `‚ö†Ô∏è Bazƒ± roller i√ßin sorun olu≈ütu: ${errors.map(e => `\`${e}\``).join(', ')}\nBotun yetkilerinin yeterli olduƒüundan ve rollerin bot rol√ºn√ºn altƒ±nda olduƒüundan emin olun.`;
    }

    if (replyMessage === '') {
        replyMessage = 'Herhangi bir rol deƒüi≈üikliƒüi yapƒ±lmadƒ±. Mevcut rolleriniz zaten se√ßiminize uygun.';
    }

    await interaction.editReply({ content: replyMessage });
}


/**
 * Rol alma/verme i≈ülemlerini bir log kanalƒ±na kaydeder. (AYNI KALACAK)
 * @param {Client} client Discord bot client
 * @param {User} user ƒ∞≈ülemi yapan kullanƒ±cƒ±
 * @param {string} roleName Etkilenen rol√ºn adƒ±
 * @param {string} action Ger√ßekle≈üen eylem (Verildi, Alƒ±ndƒ±, Ba≈üarƒ±sƒ±z vb.)
 * @param {string} color Embed rengi (hex kodu)
 * @param {string} [errorMessage] Hata mesajƒ± (sadece ba≈üarƒ±sƒ±z durumlarda)
 */
async function logRoleAction(client, user, roleName, action, color, errorMessage = null) {
    if (!ROLE_LOG_CHANNEL_ID) return;

    const logChannel = await client.channels.fetch(ROLE_LOG_CHANNEL_ID).catch(() => null);
    if (!logChannel || logChannel.type !== ChannelType.GuildText) return;

    const embed = new EmbedBuilder()
        .setColor(color)
        .setTitle(`Rol ƒ∞≈ülemi: ${roleName}`)
        .addFields(
            { name: 'Kullanƒ±cƒ±', value: `${user.tag} (${user.id})`, inline: true },
            { name: 'Eylem', value: action, inline: true }
        )
        .setTimestamp()
        .setFooter({ text: 'SomeSub Bot', iconURL: client.user.displayAvatarURL() });

    if (errorMessage) {
        embed.addFields({ name: 'Hata Detayƒ±', value: `\`\`\`${errorMessage.substring(0, 1000)}\`\`\``, inline: false });
    }

    try {
        await logChannel.send({ embeds: [embed] });
    } catch (err) {
        console.error('Rol log mesajƒ± g√∂nderilirken hata:', err.message);
    }
}


module.exports = {
    sendOrUpdateRoleMenu,
    disableRoleMenu,
    processSelectedRoles, // Fonksiyonun adƒ± deƒüi≈üti
    ROLES_INFO
};
